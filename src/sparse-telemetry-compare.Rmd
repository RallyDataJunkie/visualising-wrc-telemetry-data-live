```{r setup_sparse_telem, warning=FALSE, include=FALSE, echo=FALSE, message=FALSE, output=FALSE}
library(knitr)
library(tidyr)
library(purrr)
library(dplyr)
library(sf)
library(lubridate)
library(ggplot2)
library(leaflet)
library(kableExtra)

library(units)

source('telemetry_tools.R')

knitr.duplicate.label = "allow"
knitr::opts_chunk$set(fig.path = "images/")
```

# Comparing Drivers' Live (Sparse) Telemetry

In this chapter, we will start to explore the extent we can compare the live telemetry data traces of different drivers. Note that te data may be quite sparse at times, which might limit what we are able to do.

Where large gaps exist between data samples, we are more likely to require a sensible time model more the stage to try to minimise errors in using a simple, linear interpolator to generate missing data.

## Load Route Data

Get the route in a UTM form:

```{r}
geojson_filename = "data/finland_2021.geojson"
geojson_sf = sf::st_read(geojson_filename)

latlon_crs = 4326

# Use a convenience function that loads in the geojson file
# and then generates a spatial features dataframe with a UTM projection
stage_route_utm = get_route(geojson_sf, 7)

stage_route_utm
```

We can obtain the stage length in meters from the route:

```{r}
# Get the stage length.. this includes the units
stage_length_m = st_length(stage_route_utm)

stage_length = drop_units(stage_length_m)

stage_length
```

### Generate Buffered Route

We can also take this opportunity to create a buffered route for filtering the telemetry data:

```{r}
#Use a convenience function to get buffered route
buffer_width = 50
buffered_route = get_buffered_route(stage_route_utm, buffer_width,
                                    crs=original_crs, utm=FALSE)

leaflet(buffered_route) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addPolylines(color = "red", weight = 2)
```

## Load Driver Data

Load in data for a handful of drivers:

```{r}
# Path to the telem data
path = "../../wrcplus/notebooks/2021_secto_Rally_Finland"
```

TO DO  - set the origin as the dummy origin

```{r}
evans_min_telem = get_min_telem("Evans", "SS7", path)
evans_min_telem_utm = evans_min_telem %>%
                        st_transform(crs = st_crs(utm_proj4_string))

# Get the buffer filtered data
route_telem_evans = get_route_telem(stage_route_utm,
                                    evans_min_telem,
                                    evans_min_telem_utm)
evans_min_telem_utm
```

We can always preview the data just to check that it is sensible:

```{r}
library(leaflet)

tmp_route <- evans_min_telem %>% st_coordinates() 

leaflet(tmp_route) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addPolylines(color = "purple", weight = 5)

```

Let's get some data for some other drivers:

```{r}
fourmaux_min_telem = get_min_telem("Fourmaux", "SS7", path)

fourmaux_min_telem_utm = fourmaux_min_telem %>%
                            st_transform(crs = st_crs(utm_proj4_string))

route_telem_fourmaux = get_route_telem(stage_route_utm,
                                       fourmaux_min_telem,
                                       fourmaux_min_telem_utm)

fourmaux_min_telem_utm
```

```{r}
breen_min_telem = get_min_telem("Breen", "SS7", path)

breen_min_telem_utm = breen_min_telem %>%
                            st_transform(crs = st_crs(utm_proj4_string))

route_telem_breen = get_route_telem(stage_route_utm,
                                       breen_min_telem,
                                       breen_min_telem_utm)

route_telem_breen
```

And preview the telemetry sample points for all the drivers we have gathered telemetry data for:

```{r}
leaflet( )  %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addCircleMarkers(data=route_telem_evans, radius=1, color="blue") %>%
  addCircleMarkers(data=route_telem_breen, radius=1,color="red") %>%
  addCircleMarkers(data=route_telem_fourmaux, radius=1, color="black")
```

## Get Annotated Route Telemetry

The route telemetry annotation includes the distance along the stage route for each telemetry sample:

```{r}
route_telem_evans_utm = to_utm(route_telem_evans)
route_telem_evans_utm = route_telem_evans_utm %>% 
                          get_telem_dists(stage_route_utm)
#route_telem_evans_utm


route_telem_fourmaux_utm = to_utm(route_telem_fourmaux)
route_telem_fourmaux_utm = route_telem_fourmaux_utm %>% 
                          get_telem_dists(stage_route_utm)
route_telem_fourmaux_utm
```

## Create Driver Estimators

From the annotated data can generate some naive estimators for stage time along route based on distance along route:

```{r test_drivers_estimators}

fourmaux_time_estimator = approxfun(c(0, route_telem_fourmaux_utm$dist),
                           c(0, route_telem_fourmaux_utm$roundeddelta_s))

evans_time_estimator = approxfun(c(0, route_telem_evans_utm$dist),
                           c(0, route_telem_evans_utm$roundeddelta_s))

```


## Creating a Common False Time Origin

TO DO

## Visual Driver Comparison

Let's see if a visual comparison reveals anything:

```{r test_compare_driver_telem_linechart, warning=FALSE, mesage=FALSE}
# Sample every 500m
vals = seq(to=max(c(route_telem_fourmaux_utm$dist,
                    route_telem_evans_utm$dist)), by=500)

ggplot() + 
  # Predicted line in pink
  geom_line(aes(x=vals, y=evans_time_estimator(vals)), size=1, colour='blue') +
  geom_point(data=route_telem_evans_utm,
             aes(x=dist, y=roundeddelta_s), size=1, colour='red') +
  # Sampled times in black
  geom_line(aes(x=vals, y=fourmaux_time_estimator(vals)),
            color='red', size=1) +
  geom_point(data=route_telem_fourmaux_utm,
             aes(x=dist, y=roundeddelta_s), size=1, colour='blue')

```

# Finding the Time to Complete a Particular Stretch

In order to compare the time it takes two or more drivers to cover the same stretch of a stage route, we need to find out how long it takes each of them to cover that distance.

The following function will chunk the route into fixed length segments (exempt the final segment) and find out how long it takes the driver to complete that section.


```{r}
# Return time to travel along a segment. 
# Units relate to whether the distances are in eg m or km
segmentTimeDelta = function(driver_estimator, cumdist,
                                  stretch=100, units='m'){
  
  driver_estimator(cumdist+stretch) - driver_estimator(cumdist)
}
```

We can now generate a simple estimate of the time taken to complete each segment:

```{r}
#18163.4 %/% 1000 -> 18
# Get sections 1000m long
segment_length = 1000

#units = 'm'
#segment_length_m = set_units(segment_length, m)

segments = seq(from=0, to=stage_length, by = segment_length)

evans_1km_segments = segmentTimeDelta(evans_time_estimator,
                                      segments, segment_length)
evans_1km_segments
```


Let's also grab similar estimates for another driver:
    
```{r}
fourmaux_1km_segments = segmentTimeDelta(fourmaux_time_estimator,
                                         segments, segment_length)
fourmaux_1km_segments
```

# Estimating Time Deltas Between Drivers Over Small Sections

We can now generate a list of delta values describing the time difference between the drivers in completing each section.

__Note that if the telemetry samples are widely separated, this estimates might be quite poor, particularly if they are based on linear interpolation of times between points.__

```{r}
dummy_split_deltas = evans_1km_segments - fourmaux_1km_segments
head(dummy_split_deltas, 3)
```

If we cast the original route to a `trajr` directory, we can easily split the route into separate sections based on the cumulative distance of steps along the route.

```{r}
library(trajr)

trj <- TrajFromCoords(as.data.frame(st_coordinates(stage_route_utm)))
trj$distance = Mod(trj$displacement)

# Note that the trj object natively also provides a displacement time
trj$cum_dist = cumsum(trj$distance)
```

We can then plot the route with the time delta highlighted:

```{r}
g = ggplot()+ coord_fixed()

# Create a trace for each segment
for (i in 1:length(segments)){
  start=(i-1)*segment_length
  end= start+segment_length
  
  # Filter out the part of the trajectory we want to plot
  segment_filter = trj$cum_dist >= start & trj$cum_dist <= end
  route_segment = trj[segment_filter,]
  
  # Set colour based on delta
  c= dummy_split_deltas[i]
  if (is.na(c)) c=0
  route_segment$c = c
  
  # Add segment to plot
  g = g+geom_path(data=route_segment, aes(x=x, y=y, color=c))
}

# Render plot
g+scale_colour_gradient( low = "red", high = "green", breaks=c(0)) 
```
# TO DO

TO DO  - can we split on the route using split points a distance along the route?

```{r}
# not required?
getlocation = function(route_utm, dist, units='m') {
   sample_point_sp_utm = rgeos::gInterpolate(as(route_utm, "Spatial"),
                                          dist, # Distance along route in meters
                                          normalized = FALSE)

  # We can convert back from an sp to an sf object:
  sample_point_sf_utm = st_as_sf(sample_point_sp_utm)

  # And also convert back to a latlong reference system
  sample_point_sf = sample_point_sf_utm %>% st_transform(crs = st_crs(latlon_crs))
  sample_point_sf
}

getlocation(stage_route_utm, c(1500, 2000))
```

```{r warning=FALSE}

# Not required?
df_dummy_split_points = getlocation(stage_route_utm, segments)
df_dummy_split_coords = df_dummy_split_points %>% 
                          st_coordinates() %>% 
                          as.data.frame() %>%
                          rename(lon=X, lat=Y)

df_dummy_split_coords$delta = dummy_split_deltas

head(df_dummy_split_coords, 3)
```


We can also split the co-ordinates out from the geometry using a recipe such as:
```{r}
#https://stackoverflow.com/questions/54734771/sf-write-lat-long-from-geometry-into-separate-column-and-keep-id-column
#df %>%
#    mutate(lat = unlist(map(geometry,1)),
#           long = unlist(map(geometry,2)))
```

# Interpolation Using A Route Speed Model

Based on the curvature of the route, the speed model gives us a crude estimate of how long it takes to get between two points. If the route is a flat straight between the points, we'll travel 1km in much less time than if the route it tight and twisty.

The simple `approxfun()` interpolator uses a linear model to interpolate times between actual time points, but we might be able to improve interpolated estimates using a non-linear model based on a speed model generated over the route based on the route curvature. 

- identify distance into stage required (desired_d)
- find distance into stage for each
- get consecutive telemetry points between which desired distance lays (in_d, out_d, in_t, out_t)

```r
> l = c(1.1,2.1,3.1,4.1,5.1)
> c(l[findInterval(3, l)], l[findInterval(3, l)+1])
[1] 2.1 3.1
> c(l[findInterval(1, l)], l[findInterval(1, l)+1])
[1] 1.1
> c(l[findInterval(11, l)], l[findInterval(11, l)+1])
[1] 5.1  NA
```

- get speed model
- get model time at points (in_mt=model(in_d), out_mt=model(out_d), desired_mt=model(desired_d))
- get interpolated normalised model time between points, desired_nt = (desired_mt - in_mt)/(out_mt - in_mt)
- get predicted time desired_t = desired_nt*(out_t - in_t) + in_t


## Creating a Route Speed Model

In the *To See The Invisible* rally pacenotes tutorial series by David Nafría, corners are given a particular severity based on curvature. Simple models of expected speeds for corners of a particular severity are also described for different classes of rally car.

We can use this approach to create a simple speed model based on curvature of the rally route. Using the expected cornering speed as a target speed and a simple acceleration model, as well as theoretical maximum speed, we can accelerate the car into and out of each corner based and generate a speed model as a result.

The `rLFT` processing linear features *R* package provides a handy tool for modeling curvature along each point of a route in the form of a *boundary convexity tool* (`bct()`). The curvature of a moving segment along the route is determined, along with the center of curvature and a convexity measure.

```{r}
library(rLFT)

# The step dist is how far we move the window at each step
stepdist = 10
# The window is the length of the route for which we find the curvature
window = 20
get_route_convexity = function(route_basis_utm){
  bct(route_basis_utm,
      # distance between measurements 
      step = stepdist,
      window = window, ridName = "name") %>%
  mutate(dist =  (lead(MidMeas)-MidMeas),
         cum_dist = cumsum(dist))
}

route_convexity = get_route_convexity(stage_route_utm)

head(route_convexity, 3)
```

Although the boundary convexity tool gives us a convexity measure, we can also create our own curvature metric that corresponds more closely to Nafría's model. I don't know how to write vectorised functions properly, so I'll create a simple function that generates the curvature at a particular point on a route, and then use the `Vectorize()` helper function to as-if vectorise it for me.

```{r message=FALSE, warning=FALSE}
library(devtools)
# The curvature function takes an arc defined over
# x and y coordinate lists

#circlefit, from pracma::
circlefit = function (xp, yp, fast = TRUE) 
{
    if (!is.vector(xp, mode = "numeric") || !is.vector(yp, mode = "numeric")) 
        stop("Arguments 'xp' and 'yp' must be numeric vectors.")
    if (length(xp) != length(yp)) 
        stop("Vectors 'xp' and 'yp' must be of the same length.")
    if (!fast) 
        warning("Option 'fast' is deprecated and will not be used!", 
            call. = FALSE, immediate. = TRUE)
    n <- length(xp)
    p <- qr.solve(cbind(xp, yp, 1), matrix(xp^2 + yp^2, ncol = 1))
    v <- c(p[1]/2, p[2]/2, sqrt((p[1]^2 + p[2]^2)/4 + p[3]))
    rms <- sqrt(sum((sqrt((xp - v[1])^2 + (yp - v[2])^2) - v[3])^2)/n)
    #cat("RMS error:", rms, "\n")
    return(v)
}

curvature = function(x,y){
  #729181.8, 729186.1, 729190.4
  #4957667 , 4957676, 4957685
  tryCatch({
      # circlefit gives an error if we pass a straight line
      # Also hide the print statement in circlefit
      # circlefit() returns the x and y coords of the circle center
      # as well as the radius of curvature
      # We could then also calculate the angle and arc length
      circlefit(x,y)[3]
    },
    error = function(err) { 
      # For a straight, return the first co-ord and Inf diameter
      # Alternatively, pass zero diameter?
      c(x[1], y[1], Inf)[3]})
}

curvature2 = function(x1, x2, x3, y1, y2, y3){
  curvature(c(x1, x2, x3), c(y1, y2, y3))
}

# The base::Vectorize function provides a lazy way of 
# vectorising a non-vectorised function
curvatures = Vectorize(curvature2)
```


This model uses the corner centre measures calculated by the boundary convexity tool to return a radius for the curvature of each segment:

```{r}
route_convexity$radius = curvatures(lag(route_convexity$Midpoint_X), 
                                    route_convexity$Midpoint_X,
                                    lead(route_convexity$Midpoint_X),
                                    lag(route_convexity$Midpoint_Y),
                                    route_convexity$Midpoint_Y,
                                    lead(route_convexity$Midpoint_Y)
                                    )
```

We can now generate the cornering speed model. The corner speed model generates several things:

- a corner index, `invisble_ci`, which is an integer representing the corner radius;
- a notional segment/corner target speed, `invisible_sp`.

```{r}
corner_speed_model = function(route_convexity){
  invisible_bins = c(0, 10, 15, 20, 27.5, 35,
                    45, 60, 77.5, 100, 175, Inf)

  route_convexity$invisible_ci = cut(route_convexity$radius,
                                     breaks = invisible_bins,
                                     labels = 1:(length(invisible_bins)-1),
                                     ordered_result=TRUE)
  
  # Speeds in km/h
  invisible_speeds = c(10, 40, 50, 60, 70, 80,
                       95, 110, 120, 130, 145)
  
  
  route_convexity$invisible_sp = cut(route_convexity$radius,
                                     breaks = invisible_bins,
                                     labels = invisible_speeds,
                                     ordered_result=TRUE)
  
  # Cast speed as factor, via character, to integer
  route_convexity$invisible_sp = as.integer(as.character(route_convexity$invisible_sp))
  
  route_convexity
}

```

Applying the speed model to our route gives us a corner index and notional target speed for each segment:

```{r}
route_convexity = route_convexity %>% corner_speed_model()

head(route_convexity, 3)
```

We can build up the speed model for the route. At each step we accelerate towards the nominal sector target speed (the `invisible_sp` value). We can't accelerate infinitely fast, so our actual target accumulated speed for the segment, `acc_sp`, is a simple function of the current speed and the notional target speed. We can then calculate the notional time to complete that segment, `invisible_time`.

```{r}
acceleration_model = function(route_convexity, stepdist=10){
  # Acceleration model
  sp = route_convexity$invisible_sp
  # Nominal starting target speed
  # In we don't set this, we don't get started moving
  sp[1] = 30 
  
  # Crude acceleration / brake weights
  acc = 1
  dec = 1
  for (i in 2:(length(sp)-1)) {
    # Simple linear model - accumulated speed is based on
    # the current speed and the notional segment speed
    # Accelerate up
    if (sp[i-1]<=sp[i]) sp[i] = (sp[i-1] + acc * sp[i]) / (1+acc)
                                    
    # Decelerate down
    if (sp[i]>sp[i+1]) sp[i] = (dec * sp[i] + sp[i+1]) / (1+dec)
  }
  
  route_convexity$acc_sp = sp
  route_convexity$acc_sp[length(sp)] = route_convexity$invisible_sp[length(sp)]
  
  # New time model
  # Also get speed in m/s for time calculation
  meters = 1000
  seconds_per_hour = 3600 # 60 * 60
  kph_unit = meters / seconds_per_hour
  route_convexity = route_convexity %>% 
                      mutate(segment_sp = route_convexity$acc_sp * kph_unit,
                             invisible_time = dist/segment_sp,
                             acc_time = cumsum(invisible_time))

  
  # So now we need to generate kilometer marks
  route_convexity$kmsection = 1 + trunc(route_convexity$MidMeas/1000)
  # We can use this to help find the time over each km
  
  route_convexity
}
```

If we now apply the acceleration model to the route, we can calculate the speed over each segment, and the time taken to complete the segment:

```{r}
route_convexity = acceleration_model(route_convexity)

head(route_convexity, 3)
```

Summing over the segment times (omitting the flying finish which has no specified ongoing segment length) gives us an estimated stage time

```{r}
anticipated_time = function(route_convexity) {
  anticipated_time = sum(route_convexity$invisible_time[1:nrow(route_convexity)-1])
  cat(paste0("Anticipated stage time: ", anticipated_time %/% 60,
           'm ', round(anticipated_time %% 60, 1), 's' ))
}

anticipated_time(route_convexity)
```

We can also view the speed model over distance into stage:

```{r message=FALSE, warning=FALSE}
ggplot(route_convexity) + geom_line(aes(x=cum_dist, y=acc_sp))
```

We can also plot the time model into the stage as the accumulated time:

```{r warning=FALSE, message=FALSE,}
ggplot(route_convexity) + geom_line(aes(x=cum_dist, y=acc_time))
```



