---
title: WRC Full Telemetry Data (Quarto Live Document)
format: live-html
engine: knitr
resources:
  - resources
  - images
  - 2021_secto_Rally_Finland
---


{{< include ./_extensions/r-wasm/live/_knitr.qmd >}}

```{webr}
#| autorun: true
#| runbutton: false
#| output: false
library(knitr)
library(tidyr)
library(purrr)
library(dplyr)
library(sf)
library(trajr)
library(lubridate)
library(stringr)
library(ggplot2)
library(leaflet)
library(ggnewscale)
library(zoo)
library(smoothr)

knitr.duplicate.label = "allow"
knitr::opts_chunk$set(fig.path = "images/")

# Load in some local utility functions
source("resources/telemetry_tools.R")
```

# Get Stage Route

```{webr get_stage_route_data}
# Path to the route telemetry data
path = "./2021_secto_Rally_Finland"

geojson_filename = paste0(path, "/finland_2021.geojson")
```

*For more information on analysing rally stage routes, see [__Visualising WRC Rally Stages With rayshader and R__](https://rallydatajunkie.com/visualising-rally-stages).*

## Loading Official Stage Route Data

Let's load in some route data:

```{webr}
geojson_sf = sf::st_read(geojson_filename)
```


Let's also clean the data a little by removing the reference to the Z dimension, making a note of original co-ordinate reference scheme, and generating references to the route in both latlong and UTM forms:

```{webr process_stage_route_data}
stage_route  = geojson_sf[7,]  %>% st_zm()

# Grab a copy of the original projection
original_crs = st_crs(stage_route)

# Find the UTM zone for a sample a point on the route
crs_zone = lonlat2UTMzone(c(st_coordinates(stage_route)[1,1],
                            st_coordinates(stage_route)[1,2]))

# Create the projection string
utm_proj4_string = st_crs(crs_zone)$proj4string
#"+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"
# units in meters e.g. https://epsg.io/32632

# Transform the route projection
stage_route_utm = st_transform(stage_route,
                               crs = st_crs(utm_proj4_string))
```


# Full telemetry

As well as the sparse, low frequency telemetry that we can capture from the live data service whilst a stage is running, more substantial telemetry datasets are published several hours after a stage has run when the WRC onboard video views are made available.

The density of points is high enough to allow us to make a reasonable estimate on how far a car is into to the stage based simply on summing the distances between consecutive sample locations. However, this does mean that the distance metric is dependent on the actual route taken by a driver. Whilst drivers will typically take a similar line, a more exact comparison based on distance into the stage can be generated by mapping each sample location on the nearest location on the official route.

Inspection of the telemetry files suggests that the data is presented in a common form, with actual clock start represented by a negative time stamp injected into the second row of the dataframe. (The first and third rows are perhaps actual telemetry data.)

Load in the full resolution telemetry:

```{webr}
# Find the UTM zone for a sample a point on the route
lonlat2UTMzone = function(lonlat) {
  utm = (floor((lonlat[1] + 180) / 6) %% 60) + 1
  if(lonlat[2] > 0) {
    utm + 32600
  } else{
    utm + 32700
  }
}

#utm_proj4_string="+proj=utm +zone=35 +datum=WGS84 +units=m +no_defs"

get_full_telem = function (fp, proj="", utm=FALSE){

  telem_df_full_raw = read.csv(fp)  %>% drop_na("lon", "lat") %>% 
                  map_df(rev) %>%
   # Omit the negative start time in row 2
   filter(utx > 0)  %>%
   mutate(utc = as_datetime(utx/1000))

  # We could further tune the locations to be projections onto the route
  # This would then ensure a normalisation of the distance into the stage
  # against a common origin
  
  # TO DO - here we explicitly set the lat long crs
  # TO DO - don't use the literal 4326
  telem_df_full_raw$lonX = telem_df_full_raw$lon
  telem_df_full_raw$latX = telem_df_full_raw$lat
  telem_df_full = telem_df_full_raw  %>%
                    st_as_sf(coords = c("lonX","latX")) %>% st_set_crs(4326)

  # Inject name from file name into dataframe
  # Remove accents
  clean_fp = stringi::stri_trans_general(fp, "Latin-ASCII")
  metadata = str_match(fp, ".*df_telemetrymergeddata_(SS.*)_(.*).csv")
  stage_ =  metadata[2]
  driver_ = str_trim(stringi::stri_trans_general(metadata[3], "Latin-ASCII"))
  
  telem_df_full$driver = driver_
  telem_df_full$stage = stage_
  
  # If required, we can get a UTM projection at this point
  if (utm) {
     telem_df_full_utm =  st_transform(telem_df_full,
                           crs = st_crs(utm_proj4_string))
     telem_df_full_utm
  } else {
    telem_df_full
  }
}
```

We can then load the telemetry data in
```{webr}
path = "2021_secto_Rally_Finland"
fn="df_telemetrymergeddata_SS7_Evans.csv"
telem_df_full = get_full_telem(file.path(path, fn))
```


How many data points?

```{webr how_many}
nrow(telem_df_full %>% st_coordinates() ) 
```

As we can see, the  full telemetry gives us quite closely sampled points along the route:

```{webr}
leaflet(telem_df_full) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addCircleMarkers(weight = 1)
```


Or how about plotting the data using ggplot:

```{webr}
ggplot(data=telem_df_full) + geom_sf(aes(color=speed), size=0.1)
```

# Generating a `trajr` Route From the Telemetry Data

With a large number of points available, we can cast the dataset directly to a `trajr` route.

*The `trajr` R package was originally developed for use analysing animal tracks, but it's also really handy for analysing rally routes...*

```{webr}
telemetry_full_trajectory = function(telem_df_full){
  utm_telem_full = st_transform(telem_df_full,
                                crs=utm_proj4_string) %>% 
                      mutate(lat = st_coordinates(.)[,1],
                             lon = st_coordinates(.)[,2])

  trj <- TrajFromCoords(utm_telem_full %>% select(lon, lat, utc),
                        xCol="lon", yCol="lat", timeCol="utc")
  
  # We assume that the first location is the first location on the route
  trj$distance = Mod(trj$displacement)
  
  trj$cum_dist = cumsum(trj$distance)
  
  trj$speed  = telem_df_full$speed
  trj$brk  = telem_df_full$brk
  trj$throttle  = telem_df_full$throttle
  trj$rpm  = telem_df_full$rpm
  
  trj$lon  = telem_df_full$lon
  trj$lat  = telem_df_full$lat
  
  trj$accx = telem_df_full$accx
  trj$accy = telem_df_full$accy
      
  trj$driver =  telem_df_full$driver
  trj$stage =  telem_df_full$stage

  trj
}
```


The data includes:

- `lat`/`lon` coordinates;
- a sample timestamp;
- `speed` in km/h;
- `throttle` and `brk` (*brake*) as percentage values;
- `rpm` revs;
- `accx` and `accy` acceleration forces.

If we plot these values against the distance into stage, generated from the location data and cross-referenced to the nearest point on the official stage route, we can generate an idealised basis for comparison between different drivers. However, given that drivers typically follow a very similar line, and hence complete a similar distance over the stage, using their actual distance into the route should provide a reasonable, if approximate, basis for comparison most of the time.

The `trajr` route actually calculates a distance into the route assuming an origin based on the first point in the route.

```{webr}
evans_fn="df_telemetrymergeddata_SS7_Evans.csv"
trj_evans = telemetry_full_trajectory(get_full_telem(file.path(path, evans_fn)))

ogier_fn="df_telemetrymergeddata_SS7_Ogier.csv"
trj_ogier = telemetry_full_trajectory(get_full_telem(file.path(path, ogier_fn)))

breen_fn="df_telemetrymergeddata_SS7_Breen.csv"
trj_breen = telemetry_full_trajectory(get_full_telem(file.path(path, breen_fn)))
```

# Finding Distance into a Common Route

To provide for an exact comparison of times based on distance into stage, we can map distances onto the "official" route.

However, if the official route does not match the actual route, we may get a "false" distance measures. For example, if the "official" route starts some way along the actual route as recorded in telemetry, then we will lose information at the start of the route.

Another approach might be to generate out own unofficial official route by creating a small buffer around the intersection of the captured route telemetry and then looking up roads using OSM within that buffered area; such a road should be unique (assuming that the stage route follows tracks that appear on OpenStreetMap) and could then be used as the official route.

```{webr}
dist_into_route = function(trj_utm, stage_route_utm) {
  # Ensure consistent CRS
  trj_utm <- st_transform(trj_utm, crs = st_crs(stage_route_utm))
  
  # Create spatial points from trajectory
  full_pois_points_utm = st_geometry(trj_utm)
  
  # Convert route to sf object if not already
  route_sf <- st_as_sf(stage_route_utm)
  
  # Project points onto the line and find distances
  dist_points <- st_line_sample(route_sf, density = 1) %>% 
    st_nearest_points(full_pois_points_utm)
  
  # Get nearest points on the line
  nearest_points_on_line <- st_cast(dist_points, "POINT")[c(FALSE, TRUE)]
  
  # Find distances along the route
  point_dists <- st_line_project(st_as_sfc(route_sf), nearest_points_on_line)
  
  return(point_dists)
}
```

We can now get the distance into route for each telemetry point:

```{webr warning=FALSE}
# This throws a warning?
trj_evans$dist_into_route = dist_into_route(trj_evans, stage_route_utm)
trj_ogier$dist_into_route = dist_into_route(trj_ogier, stage_route_utm)
```

Another approach would be simple to project one driver's route onto the route taken by a driver we are comparing them against and then finding times based distance into this common route projection.

# Looking At Braking Behaviour

Where do we brake?

```{webr}
#library(ggspatial)
#  annotation_spatial(trj_ogier ) +
#  layer_spatial(trj_ogier, aes(alpha = brk), color='red',size=0.3) 

#https://github.com/eliocamp/ggnewscale
# Multiple color scales
# ?doesn't work with geom_sf which overplots?
library(ggnewscale)
ggplot() + stat_sf_coordinates(aes( color=throttle),size=0.1,
  geom = "point",
 data=trj_ogier %>% filter(throttle>0)) +
scale_color_gradient(low = "white", high = "green") +
 new_scale_color() + 
scale_color_gradient(low = "white", high = "red")+ stat_sf_coordinates( aes( color=brk), size=0.1,
  geom = "point",
  data=trj_ogier %>% filter(brk>0)
) + 
# How do we get the correct projection
#_coord_map()
# Already rectilinear...
  coord_fixed()
```

## Throttle Comparison

How do our two drivers compare in their use of the throttle?

```{webr compare_drivers_plot}
ggplot() +
  geom_line(data=(trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000)),
            aes(x=cum_dist,y=throttle), color='red') +
  geom_line(data=(trj_evans %>% filter(cum_dist>=1000 & cum_dist<=2000)),
            aes(x=cum_dist,y=throttle), color='blue')
```

With smoothing:

```{webr}
library(zoo)

ggplot() +
  geom_line(data=trj_ogier%>% filter(cum_dist>=1000 & cum_dist<=2000) %>%
                    mutate(smooth_throttle=rollmean(throttle, k = 3, fill = NA)),
            aes(x=cum_dist,y=smooth_throttle), color='red') +
  geom_line(data=(trj_evans %>% filter(cum_dist>=1000 & cum_dist<=2000) %>%
                    mutate(smooth_throttle=rollmean(throttle, k = 3, fill = NA))),
            aes(x=cum_dist,y=smooth_throttle), color='blue')


```

We can also explore adding throttle and brake data to the speed trace.


```{webr}
theme_black = function(base_size = 12, base_family = "") {
  
  theme_grey(base_size = base_size, base_family = base_family) %+replace%
    
    theme(
      # Specify axis options
      axis.line = element_blank(),  
      axis.text.x = element_text(size = base_size*0.8, color = "white", lineheight = 0.9),  
      axis.text.y = element_text(size = base_size*0.8, color = "white", lineheight = 0.9),  
      axis.ticks = element_line(color = "white", linewidth  =  0.2),  
      axis.title.x = element_text(size = base_size, color = "white", margin = margin(0, 10, 0, 0)),  
      axis.title.y = element_text(size = base_size, color = "white", angle = 90, margin = margin(0, 10, 0, 0)),  
      axis.ticks.length = unit(0.3, "lines"),   
      # Specify legend options
      legend.background = element_rect(color = NA, fill = "black"),  
      legend.key = element_rect(color = "white",  fill = "black"),  
      legend.key.size = unit(1.2, "lines"),  
      legend.key.height = NULL,  
      legend.key.width = NULL,      
      legend.text = element_text(size = base_size*0.8, color = "white"),  
      legend.title = element_text(size = base_size*0.8, face = "bold", hjust = 0, color = "white"),  
      legend.position = "right",  
      legend.text.align = NULL,  
      legend.title.align = NULL,  
      legend.direction = "vertical",  
      legend.box = NULL, 
      # Specify panel options
      panel.background = element_rect(fill = "black", color  =  NA),  
      panel.border = element_rect(fill = NA, color = "white"),  
      panel.grid.major = element_line(color = "grey35"),  
      panel.grid.minor = element_line(color = "grey20"),  
      panel.spacing = unit(0.5, "lines"),   
      # Specify faceting options
      strip.background = element_rect(fill = "grey30", color = "grey10"),  
      strip.text.x = element_text(size = base_size*0.8, color = "white"),  
      strip.text.y = element_text(size = base_size*0.8, color = "white",angle = -90),  
      # Specify plot options
      plot.background = element_rect(color = "black", fill = "black"),  
      plot.title = element_text(size = base_size*1.2, color = "white"),  
      plot.margin = unit(rep(1, 4), "lines")
      
    )
  
}
```

What happens if we try to colour the speed line according to the throttle and brake percentages?

```{webr}
ggplot() +
  #geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
  #          aes(x=cum_dist,y=speed), color='white', linewidth=4) +
   geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
            aes(x=cum_dist,y=speed, alpha=throttle), linewidth=1, color="green") +
  geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
            aes(x=cum_dist,y=speed-3, alpha=brk), color="red", linewidth=1) +
   geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
            aes(x=cum_dist,y=throttle-50, alpha=100-brk), linewidth=1, color="green") +
  geom_line(data=trj_ogier %>% filter(cum_dist>=1000 & cum_dist<=2000),
            aes(x=cum_dist,y=brk-50, alpha=100-throttle), color="red", linewidth=1)+
  
  theme_black()+ theme(legend.position="none")
```

```{webr}
ggplot(data=telem_df_full) + geom_sf(aes(color=throttle), size=0.1)
```

```{webr}
ggplot(data=telem_df_full) + geom_sf(aes(color=-brk), size=0.1)
```


# Comparing Times Into Stage

How do our drivers compare based on the time it takes them to driver a particular distance into the stage?

*Recall that we are using each car's own accumulated distance in to stage measure, rather than comparing times at distances into stage measured along some common, idealised route.*

Sample common points to find the difference:

```{webr}
segment_length=100

# stage_length set in earlier section
segments = seq(from=0, to=stage_length, by = segment_length)

ogier_full_estimator = approxfun(trj_ogier$cum_dist,
                            trj_ogier$displacementTime)

evans_full_estimator = approxfun(trj_evans$cum_dist,
                           trj_evans$displacementTime)

ogier_time_points = ogier_full_estimator(segments)
evans_time_points = evans_full_estimator(segments)

ogier_evans_point_delta = ogier_time_points - evans_time_points

# Difference in time take to reach a particular point in the stage
ggplot()+geom_line(aes(x=segments, y=ogier_evans_point_delta))
```


Compare time into stage for a given distance into stage. Note that this is the distance into the stage as calculated from the trajectory, rather than by comparison of distances into the same (idealised) route.

```{webr}
ggplot() +
  geom_line(data=(trj_ogier %>% mutate(dt=as.double(displacementTime)) %>% filter(dt >=0)),
            aes(x=cum_dist,y=dt), color='blue') +
  geom_line(data=(trj_evans %>% mutate(dt=as.double(displacementTime)) %>% filter(dt >=0)),
            aes(x=cum_dist,y=dt), color='grey') 
```

# Correlating Telemetry Traces

We can use a cross-correlation function to try to identify the extent to which traces are similar across drivers. The `approxfun()` estimator does a very simple interpoloation between consecutive values in the original dataset, which means that actual telemetry data values are pinned in the prediction model and used for local estimation. 

```{webr}
ts_estimator = function(df, x, y, points){
  estimator_ = approxfun(df[[x]], df[[y]])
  estimator_(points)
}
```

We can use this function to estimate different properties from the time series telemetry data. 

```{webr}
ogier_speed_est = ts_estimator(trj_ogier, "cum_dist", "speed", segments)
evans_speed_est = ts_estimator(trj_evans, "cum_dist", "speed", segments)

speed_correlation_ogier_evans =  ccf(ogier_speed_est, evans_speed_est)
speed_correlation_ogier_evans
```

We can report on the correlation at different lags by using the lag value as an index value:

```{webr}
lag = 0

speed_correlation_ogier_evans[lag]
```

Brake cross-correlation:

```{webr}
ogier_brk_est = ts_estimator(trj_ogier, "cum_dist", "brk", segments)
evans_brk_est = ts_estimator(trj_evans, "cum_dist", "brk", segments)

ccf(ogier_brk_est, evans_brk_est)
```

*It occurs to me that if we use a high resolution sample, for example at the level of 1m, we might be able to detect consistent areas where one driver brakes sooner than another. This may be hard to spot in rally telemetry, but it may be something observable in circuit races over many laps of the same circuit.*

# Smoothing a Route

If we have a route made up from a set of points, we find an smooth trajectory through them using a function such as a the `smoothr::smooth()` function. The `trajr` package also has a smoothing function in the form of `TrajSmoothSG()`.

```{webr}
smooth_route_utm = smoothr::smooth(stage_route_utm,
                                   method = "ksmooth")
```

We can preview the route to on an interactive map so we can zoom in to see where the smooth route might diverge from the provided route.

```{webr}
smooth_route = st_transform(smooth_route_utm,
                            crs = st_crs(original_crs)) %>% st_coordinates()
smooth_route = smooth_route[,1:2]

official_route = st_transform(stage_route_utm,
                              crs = st_crs(original_crs)) %>% st_coordinates()
official_route = official_route[,1:2]

leaflet(smooth_route) %>% 
  addProviderTiles("OpenTopoMap", group = "OSM") %>% 
  addPolylines()
```

However, the smoothing is based on being provided with an actual route. If we have data from multiple drivers representing multiple routes, whilst we can visualise the route as a set of points and "see" the route they tend to follow, it's hard to see *a priori* how we might order those points into an approximate route given that the distance along route may vary slightly and the time along route at particular locations is also likely to vary.

Thinking a bit more ecologically, we might perhaps consider a group of animals following the same (ish) path over a period of time and then trying to work out the route they take from those separate sets of sample data. How do the ecologists do that?

If we know the start and end of the route are nominally at the same location, we can normalise the route length of multiple routes, map equidistant points onto each other, and then take the average. For example, this solution: https://stackoverflow.com/a/65341730/454773 . See also https://en.wikipedia.org/wiki/Dynamic_time_warping and https://dynamictimewarping.github.io/r/ .

# Validating the Speed Model 

We can use the telemetry from a route to validate (or not!) our speed model. So let's have a go at that...

We already have a stage route available, so let's recap how to generate the speed model from a stage route. To ty to improve the model, we can use the smmoothed route. For many parts of the stage, the smoothed route is likely to give a better estimate of the line. However, for certain stage features, such as hairpins, the smoothing may be over-optimistic and take an impossible line.

```{webr route_convexity}
#stepdist = 10
#window = 20

# Original route: stage_route_utm
# Smooth route: smooth_route_utm
route_ = smooth_route_utm
route_convexity = get_route_convexity(route_, stepdist, window) %>% 
                      mutate(radius = curvatures(.)) %>% 
                      corner_speed_model(speed_modifier=-1) %>% 
                      acceleration_model(acc=0.1, dec=0.05)

# Generate speed points at same sample distances as in speed model
sample_points = route_convexity$cum_dist
```

To validate the model, we need to ensure that we are testing the telemetry within the buffered route area and also ensure we are using similar sample distances.

```{webr warning=FALSE, message=FALSE}
buffer_width = 50
buffered_route = get_buffered_route(stage_route_utm, buffer_width,
                                    crs=original_crs, utm=FALSE)

telem_df_full_test_utm = get_full_telem(file.path(path, fn), utm=TRUE)
buffered_telem_test_utm = get_route_telem(stage_route_utm,
                                          telem_df_full_test_utm)

trj_buffered_test = buffered_telem_test_utm %>%
                        telemetry_full_trajectory() %>%
                        mutate(dist_into_route = dist_into_route(., stage_route_utm))

# Estimate based on telemetry
test_speeds = ts_estimator(trj_buffered_test,
                           "cum_dist", "speed", sample_points)

#test_speeds = test_estimator(sample_points)
```

We can plot the actual speed (as captured  telemetry) along with the interpolated speed at regular points along the stage to check the behaviour of the interpolator.

```{webr message=FALSE, warning=FALSE}
# Just quickly check that the sample speed model approximates the raw data
ggplot() + 
  geom_line(data=trj_buffered_test,
                     aes(x=dist_into_route, y=speed)) +
  geom_line(aes(x=sample_points, y=test_speeds),
            color='red', linetype = "dashed")
```

Comparing the traces, the simple estimator appears to do a reasonable job of interpolating speeds between the sample points, which means we can get a reasonable estimate of speed, from the telemetry, at any point along the route.

How well does the time into stage interpolation work (which is to say: can we reliably interpolate the time into stage from a telemetry based model)?

```{webr message=FALSE, warning=FALSE}
test_times = ts_estimator(trj_buffered_test,
                          "cum_dist", "displacementTime", sample_points)

ggplot() + 
  geom_line(data=trj_buffered_test,
                     aes(x=dist_into_route, y=displacementTime)) +
  geom_line(aes(x=sample_points, y=test_times),
            color='red', linetype = "dashed")
```

Again, that looks reasonable.

Now let's see how our simple speed model works. To begin with, how well do the speeds predicted by the speed model, based on stage route analysis, compared with speeds captured from telemetry?

```{webr warning=FALSE}
# Just quickly check that the sample speed model approximates the raw data
ggplot() + 
  geom_line(data=route_convexity,
                     aes(x=cum_dist, y=acc_sp)) +
  geom_line(aes(x=sample_points, y=test_speeds),
            color='red') +
  geom_line(aes(x=sample_points, y=test_speeds - route_convexity$acc_sp),
            color='blue')
```

We can also find a simple cross correlation between the speed model and some speed telemetry data:

```{webr}
speed_correlation = ccf(route_convexity$acc_sp, test_speeds, na.action=na.pass)

speed_correlation
```

The model is a bit rough, bit captures some of the major features, and gives us a crude approximation of speed.

Perhaps more important from the perspective of using the speed model as a basis for predictions of time into stage, let's see how the time into stage prediction compares with the actual time into stage at particular locations as captured from telemetry:

```{webr warning=FALSE, message=FALSE}
ggplot() + 
  geom_line(data=route_convexity,
                     aes(x=cum_dist, y=acc_time)) +
  geom_line(aes(x=sample_points, y=test_times),
            color='red') +
  geom_line(aes(x=sample_points, y=test_times - route_convexity$acc_time),
            color='blue')
```

There appear to be two types of error in the prediction: a general trend component error, where the prediction appears to drift consistently from the actual time into stage as captured from telemetry; and a possible difference in "shape" of the lines.

We can modify the model to account for the linear dirft by tweaking the cornering speed model. A trivial way to do this is to fettle the `speed_modifier` parameter in the `corner_speed_model()` function.

We can detrend the prediction error to get a feel how the "shape" of the predicted time drifts from the actual time. One way of detrending the data is to create a linear model of it and then inspect the residual error around that model.

```{webr warning=FALSE, message=FALSE}
linear_time_model = lm((test_times - route_convexity$acc_time) ~ c(1:length(test_times)))

plot(resid(linear_time_model), type="l") 
```

By inspection of the elevation map for this stage, we may be lossing time in the model compared to the actual telemetry on downhill sections. The speed model does not currently take elevation / elevation change into account. But perhaps it should, particularly on downhill sections?

Another approach is to normalise the curves and then compare them:

```{webr warning=FALSE, message=FALSE}
test_times_normalised = test_times / max(test_times, na.rm=T)
acc_time_normalised = route_convexity$acc_time / max(route_convexity$acc_time,
                                                     na.rm=T)

ggplot() + 
  geom_line(aes(x=sample_points, y=acc_time_normalised)) +
  geom_line(aes(x=sample_points, y=test_times_normalised),
            color='red')

```

We can also compare the error between the actual times into stage and the predicted times, and the actual times into stage compared to a linear model.

If the error of the predicted time into stage is less than that of the linear model, then it adds some value to time predictions based on sparse telemetry.

```{webr warning=FALSE, message=FALSE}
ggplot() + 
  geom_line(aes(x=sample_points, y=test_times_normalised - acc_time_normalised),
            color='blue') + 
   geom_line(aes(x=sample_points,
                 y=acc_time_normalised - sample_points/max(sample_points, na.rm=T)),
            color='red')
```


# Numbering Corners

```{webr}
cornerer = function (df, slight_conv=0.02, closeby=25){
  df %>%
    mutate(straightish =  (abs(ConvexityIndex) < slight_conv)) %>%
    mutate(dirChange = (sign(ConvexityIndex) != sign(lag(ConvexityIndex,2))
                          ) 
   #        | (straightish & !lag(straightish) ) | (!straightish & lag(straightish)) 
   ) %>%

    mutate(turn= ifelse( straightish, "S", ifelse(ConvexityIndex<0, "L", "R"))) %>%
     # If we are on R or L and then we go to S11, we need call a slight L or R
    mutate(turn = ifelse(turn!="S" & lag(turn)=="S", ifelse(turn=="R", "L","R"), turn)) %>%
    mutate(s2 = replace_na(turn!=lag(turn), TRUE) ) %>% 
    mutate(streak_id=cumsum(s2)) %>% group_by(streak_id) %>%  mutate(streak=row_number()) %>%
ungroup()
}

xx = cornerer(route_convexity)

yy = xx %>% group_by(streak_id) %>%
   mutate(invisible_ci = min(invisible_ci), kmsection=min(kmsection)) %>%
  mutate(x=head(Midpoint_X,1), y=head(Midpoint_Y,1)) %>%
  filter(row_number()==n())
  #mutate(txt = ifelse(invisible_ci>9 & turn!="S",
  #                    paste("slight ",turn, as.character(10*streak)),
  #                    ifelse(turn=="S", as.character(10*streak), "")),
  #       txt=ifelse(paste(txt, paste0(invisible_ci, streak, turn), sep=", "))
  #       )
#
xx
```

```{webr}
xx %>% filter(kmsection==2) %>% select(straightish, dirChange, turn, invisible_ci)
```


```{webr}
yy = yy %>% mutate(txt = ifelse(invisible_ci>9 & turn=="S",paste(streak*10),
                           ifelse(invisible_ci>9, paste("slight",turn, streak*10),
                                  paste(paste0(streak, invisible_ci), turn)))) %>%
  select(kmsection, invisible_ci, turn, streak_id, streak, txt, x, y)
#
zz= yy %>% group_by(kmsection) %>% 
  summarise(txt=paste(txt, collapse=", "))
zz
#yy
```

```{webr}
tmp_data = yy %>% filter(kmsection==2)
tmp_data2 = xx %>% filter(kmsection==2)
ggplot(tmp_data2) + geom_text(data=head(tmp_data2, 1),aes(x=Midpoint_X, y=Midpoint_Y),label="X" , color="green") +
  geom_path(aes(x=Midpoint_X, y=Midpoint_Y)) +
  ggrepel::geom_text_repel(data=tmp_data, aes(x=x, y=y, label=txt), size=2)+
  coord_fixed() + geom_point(data=tmp_data, aes(x=x, y=y)) + xlim(min(tmp_data2$Midpoint_X)-100, max(tmp_data2$Midpoint_X)+100)
```


```{webr}
zz[[2,'txt']]
```


```{webr}

ggplot(tmp_data, aes(x=x, y=y))+
  geom_text(data=head(tmp_data,1), label="X") +
  geom_path() +
  coord_fixed() +geom_point(color='red', size=1) 
```




ggplot(data=trj[zoom1,],
       aes(x=x, y=y)) + geom_path(color='grey') + coord_sf() +
  ggrepel::geom_text_repel(data=tight_corners[tight_corners_zoom1,],
                           aes(label = dist,
                               x=Midpoint_X, y=Midpoint_Y),
                           size=3) +
  geom_point(data=tight_corners[tight_corners_zoom1,],
             aes(x=Midpoint_X, y=Midpoint_Y,
                 color= (firstish) ), size=1) +
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45))
```{webr}
ggplot() +
  #geom_point(data=xx,
  #           aes(x=Midpoint_X, y=Midpoint_Y,
  #                ), color='pink', size=1) +
  geom_point(data=xx,
             aes(x=Midpoint_X, y=Midpoint_Y,color=turn), size=0.2) +
  geom_point(data=xx %>% filter(s2==TRUE),
             aes(x=Midpoint_X, y=Midpoint_Y
                  ),color="black", size=0.1) +
  theme_classic()+
  theme(axis.text.x = element_text(angle = 45))
```